#!/usr/bin/env python3
"""
Vulnerability detection module for static analysis security scanning (SAS).
Identifies security vulnerabilities and coding issues in repository source code.
"""

import os
import re
import json
import logging
from typing import Dict, List, Any, Tuple
from collections import defaultdict
from dataclasses import dataclass
from enum import Enum

logging.basicConfig(
    filename="crawler.log",
    filemode="a",
    format="%(asctime)s %(levelname)s: %(message)s",
    level=logging.INFO
)

class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class VulnerabilityFinding:
    """Represents a single vulnerability finding."""
    rule_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    category: str
    file_path: str
    line_number: int
    code_snippet: str
    cwe_id: str = None
    recommendation: str = ""

class VulnerabilityScanner:
    """
    Static analysis security scanner for identifying vulnerabilities in source code.
    """
    
    def __init__(self, threshold: VulnerabilitySeverity = VulnerabilitySeverity.MEDIUM):
        """
        Initialize vulnerability scanner.
        
        Args:
            threshold: Minimum severity level to report
        """
        self.threshold = threshold
        self.findings = []
        self.rules = self._initialize_vulnerability_rules()
        
        # File extensions to scan
        self.scannable_extensions = {
            '.py', '.js', '.ts', '.java', '.cpp', '.c', '.h', '.hpp', '.cs', '.go',
            '.rs', '.php', '.rb', '.swift', '.kt', '.scala', '.sql', '.sh', '.bash',
            '.ps1', '.yaml', '.yml', '.json', '.xml'
        }
    
    def _initialize_vulnerability_rules(self) -> List[Dict[str, Any]]:
        """Initialize vulnerability detection rules."""
        rules = []
        
        # SQL Injection vulnerabilities
        rules.extend([
            {
                'id': 'SQL_INJECTION_001',
                'pattern': r'(SELECT|INSERT|UPDATE|DELETE).*\+.*["\']',
                'title': 'Potential SQL Injection via String Concatenation',
                'description': 'SQL query constructed using string concatenation, vulnerable to injection',
                'severity': VulnerabilitySeverity.HIGH,
                'category': 'injection',
                'cwe': 'CWE-89',
                'recommendation': 'Use parameterized queries or prepared statements'
            },
            {
                'id': 'SQL_INJECTION_002', 
                'pattern': r'execute\s*\(\s*["\'].*%.*["\']',
                'title': 'SQL Query with String Formatting',
                'description': 'SQL query uses string formatting which may be exploitable',
                'severity': VulnerabilitySeverity.HIGH,
                'category': 'injection',
                'cwe': 'CWE-89',
                'recommendation': 'Use parameterized queries instead of string formatting'
            }
        ])
        
        # Command Injection vulnerabilities
        rules.extend([
            {
                'id': 'CMD_INJECTION_001',
                'pattern': r'(subprocess\.(run|call|Popen)|os\.system|exec|eval)\s*\([^)]*\+',
                'title': 'Command Injection via String Concatenation',
                'description': 'System command constructed using concatenation, vulnerable to injection',
                'severity': VulnerabilitySeverity.CRITICAL,
                'category': 'injection',
                'cwe': 'CWE-78',
                'recommendation': 'Validate and sanitize input, use subprocess with argument lists'
            },
            {
                'id': 'CMD_INJECTION_002',
                'pattern': r'shell\s*=\s*True',
                'title': 'Shell Command Execution Enabled',
                'description': 'subprocess call with shell=True can be dangerous',
                'severity': VulnerabilitySeverity.MEDIUM,
                'category': 'injection',
                'cwe': 'CWE-78',
                'recommendation': 'Avoid shell=True, use argument lists instead'
            }
        ])
        
        # Path Traversal vulnerabilities
        rules.extend([
            {
                'id': 'PATH_TRAVERSAL_001',
                'pattern': r'(open|file|read|write)\s*\([^)]*\.\./.*["\']',
                'title': 'Path Traversal Attack Pattern',
                'description': 'File access using relative paths with ../ sequences',
                'severity': VulnerabilitySeverity.HIGH,
                'category': 'path_traversal',
                'cwe': 'CWE-22',
                'recommendation': 'Use absolute paths or validate/sanitize file paths'
            },
            {
                'id': 'PATH_TRAVERSAL_002',
                'pattern': r'(sendfile|serve_file).*\+.*user',
                'title': 'File Serving with User Input',
                'description': 'File serving functionality uses user input in path construction',
                'severity': VulnerabilitySeverity.MEDIUM,
                'category': 'path_traversal',
                'cwe': 'CWE-22',
                'recommendation': 'Validate file paths and restrict access to allowed directories'
            }
        ])
        
        # Cross-Site Scripting (XSS) vulnerabilities
        rules.extend([
            {
                'id': 'XSS_001',
                'pattern': r'innerHTML\s*=.*\+',
                'title': 'Potential XSS via innerHTML',
                'description': 'innerHTML assignment with concatenated user input',
                'severity': VulnerabilitySeverity.MEDIUM,
                'category': 'xss',
                'cwe': 'CWE-79',
                'recommendation': 'Use textContent or sanitize HTML input'
            },
            {
                'id': 'XSS_002',
                'pattern': r'document\.write\s*\([^)]*\+',
                'title': 'XSS via document.write',
                'description': 'document.write with concatenated input can lead to XSS',
                'severity': VulnerabilitySeverity.HIGH,
                'category': 'xss',
                'cwe': 'CWE-79',
                'recommendation': 'Avoid document.write, use DOM manipulation methods'
            }
        ])
        
        # Cryptographic vulnerabilities
        rules.extend([
            {
                'id': 'CRYPTO_001',
                'pattern': r'(MD5|SHA1)\s*\(',
                'title': 'Weak Cryptographic Hash Function',
                'description': 'Use of weak hash function MD5 or SHA1',
                'severity': VulnerabilitySeverity.MEDIUM,
                'category': 'crypto',
                'cwe': 'CWE-327',
                'recommendation': 'Use SHA-256 or stronger hash functions'
            },
            {
                'id': 'CRYPTO_002',
                'pattern': r'password\s*=\s*["\'][^"\']{1,8}["\']',
                'title': 'Weak Password/Key',
                'description': 'Hardcoded weak password or encryption key',
                'severity': VulnerabilitySeverity.HIGH,
                'category': 'crypto',
                'cwe': 'CWE-798',
                'recommendation': 'Use strong, randomly generated passwords/keys'
            },
            {
                'id': 'CRYPTO_003',
                'pattern': r'(AES|DES).*ECB',
                'title': 'Weak Encryption Mode',
                'description': 'Use of ECB mode which is cryptographically weak',
                'severity': VulnerabilitySeverity.MEDIUM,
                'category': 'crypto',
                'cwe': 'CWE-327',
                'recommendation': 'Use CBC, GCM, or other secure encryption modes'
            }
        ])
        
        # Information Disclosure vulnerabilities
        rules.extend([
            {
                'id': 'INFO_DISCLOSURE_001',
                'pattern': r'(api_key|secret_key|password|token)\s*=\s*["\'][^"\']+["\']',
                'title': 'Hardcoded Sensitive Information',
                'description': 'Sensitive information hardcoded in source code',
                'severity': VulnerabilitySeverity.HIGH,
                'category': 'secrets',
                'cwe': 'CWE-798',
                'recommendation': 'Use environment variables or secure configuration files'
            },
            {
                'id': 'INFO_DISCLOSURE_002',
                'pattern': r'print\s*\([^)]*password',
                'title': 'Sensitive Information in Logs',
                'description': 'Potentially logging sensitive information',
                'severity': VulnerabilitySeverity.MEDIUM,
                'category': 'logging',
                'cwe': 'CWE-532',
                'recommendation': 'Avoid logging sensitive information'
            }
        ])
        
        # Deserialization vulnerabilities
        rules.extend([
            {
                'id': 'DESERIAL_001',
                'pattern': r'pickle\.loads?\s*\(',
                'title': 'Unsafe Deserialization',
                'description': 'Use of pickle.loads which can execute arbitrary code',
                'severity': VulnerabilitySeverity.CRITICAL,
                'category': 'deserialization',
                'cwe': 'CWE-502',
                'recommendation': 'Use safe serialization formats like JSON'
            },
            {
                'id': 'DESERIAL_002',
                'pattern': r'eval\s*\(',
                'title': 'Code Injection via eval()',
                'description': 'eval() can execute arbitrary code from strings',
                'severity': VulnerabilitySeverity.CRITICAL,
                'category': 'injection',
                'cwe': 'CWE-94',
                'recommendation': 'Avoid eval(), use ast.literal_eval() for safe evaluation'
            }
        ])
        
        # Race Condition vulnerabilities
        rules.extend([
            {
                'id': 'RACE_CONDITION_001',
                'pattern': r'(os\.path\.exists|isfile)\s*\([^)]+\).*open\s*\(',
                'title': 'Time-of-Check Time-of-Use (TOCTOU)',
                'description': 'File existence check followed by file operation creates race condition',
                'severity': VulnerabilitySeverity.MEDIUM,
                'category': 'race_condition',
                'cwe': 'CWE-367',
                'recommendation': 'Use try/except blocks instead of existence checks'
            }
        ])
        
        # Buffer Overflow vulnerabilities (C/C++)
        rules.extend([
            {
                'id': 'BUFFER_OVERFLOW_001',
                'pattern': r'(strcpy|strcat|sprintf|gets)\s*\(',
                'title': 'Unsafe C String Function',
                'description': 'Use of unsafe C string function that can cause buffer overflow',
                'severity': VulnerabilitySeverity.HIGH,
                'category': 'buffer_overflow',
                'cwe': 'CWE-120',
                'recommendation': 'Use safe alternatives like strncpy, strncat, snprintf'
            }
        ])
        
        return rules
    
    def scan_repository(self, repo_path: str) -> Dict[str, Any]:
        """
        Scan repository for vulnerabilities.
        
        Args:
            repo_path: Path to repository to scan
            
        Returns:
            Dictionary containing vulnerability scan results
        """
        logging.info(f"Starting vulnerability scan of repository: {repo_path}")
        
        self.findings = []
        file_count = 0
        
        try:
            for root, dirs, files in os.walk(repo_path):
                # Skip .git directory
                if ".git" in dirs:
                    dirs.remove(".git")
                
                for filename in files:
                    file_path = os.path.join(root, filename)
                    rel_path = os.path.relpath(file_path, repo_path)
                    
                    if self._should_scan_file(filename):
                        self._scan_file(file_path, rel_path)
                        file_count += 1
            
            # Generate scan results
            results = self._generate_results(repo_path, file_count)
            
            logging.info(f"Vulnerability scan completed: {len(self.findings)} findings in {file_count} files")
            return results
            
        except Exception as e:
            logging.error(f"Error during vulnerability scan of {repo_path}: {e}")
            return {}
    
    def _should_scan_file(self, filename: str) -> bool:
        """Determine if file should be scanned."""
        _, ext = os.path.splitext(filename.lower())
        return ext in self.scannable_extensions
    
    def _scan_file(self, file_path: str, rel_path: str):
        """Scan individual file for vulnerabilities."""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                for rule in self.rules:
                    if re.search(rule['pattern'], line, re.IGNORECASE):
                        # Check if finding meets threshold
                        if self._meets_threshold(rule['severity']):
                            finding = VulnerabilityFinding(
                                rule_id=rule['id'],
                                title=rule['title'],
                                description=rule['description'],
                                severity=rule['severity'],
                                category=rule['category'],
                                file_path=rel_path,
                                line_number=line_num,
                                code_snippet=line.strip(),
                                cwe_id=rule.get('cwe'),
                                recommendation=rule.get('recommendation', '')
                            )
                            self.findings.append(finding)
        
        except Exception as e:
            logging.warning(f"Error scanning file {file_path}: {e}")
    
    def _meets_threshold(self, severity: VulnerabilitySeverity) -> bool:
        """Check if finding severity meets configured threshold."""
        severity_levels = {
            VulnerabilitySeverity.INFO: 0,
            VulnerabilitySeverity.LOW: 1,
            VulnerabilitySeverity.MEDIUM: 2,
            VulnerabilitySeverity.HIGH: 3,
            VulnerabilitySeverity.CRITICAL: 4
        }
        
        return severity_levels.get(severity, 0) >= severity_levels.get(self.threshold, 2)
    
    def _generate_results(self, repo_path: str, file_count: int) -> Dict[str, Any]:
        """Generate scan results summary."""
        # Group findings by various attributes
        by_severity = defaultdict(int)
        by_category = defaultdict(int)
        by_file = defaultdict(list)
        
        for finding in self.findings:
            by_severity[finding.severity.value] += 1
            by_category[finding.category] += 1
            by_file[finding.file_path].append({
                'rule_id': finding.rule_id,
                'title': finding.title,
                'severity': finding.severity.value,
                'line_number': finding.line_number,
                'code_snippet': finding.code_snippet
            })
        
        # Calculate risk score
        risk_score = self._calculate_risk_score(by_severity)
        
        results = {
            'repository_path': repo_path,
            'scan_timestamp': str(__import__('datetime').datetime.now()),
            'files_scanned': file_count,
            'total_findings': len(self.findings),
            'findings_by_severity': dict(by_severity),
            'findings_by_category': dict(by_category),
            'findings_by_file': dict(by_file),
            'risk_score': risk_score,
            'risk_level': self._get_risk_level(risk_score),
            'threshold_used': self.threshold.value,
            'top_categories': sorted(by_category.items(), key=lambda x: x[1], reverse=True)[:5]
        }
        
        return results
    
    def _calculate_risk_score(self, by_severity: Dict[str, int]) -> float:
        """Calculate overall risk score based on findings."""
        severity_weights = {
            'critical': 10.0,
            'high': 7.0,
            'medium': 4.0,
            'low': 2.0,
            'info': 1.0
        }
        
        total_score = 0.0
        for severity, count in by_severity.items():
            weight = severity_weights.get(severity, 1.0)
            total_score += count * weight
        
        # Normalize to 0-10 scale (cap at 10)
        return min(round(total_score / 10, 2), 10.0)
    
    def _get_risk_level(self, risk_score: float) -> str:
        """Get risk level based on score."""
        if risk_score >= 8.0:
            return "CRITICAL"
        elif risk_score >= 6.0:
            return "HIGH" 
        elif risk_score >= 4.0:
            return "MEDIUM"
        elif risk_score >= 2.0:
            return "LOW"
        else:
            return "MINIMAL"
    
    def export_findings(self, output_path: str, format: str = 'json'):
        """Export findings to file."""
        if format.lower() == 'json':
            findings_data = []
            for finding in self.findings:
                findings_data.append({
                    'rule_id': finding.rule_id,
                    'title': finding.title,
                    'description': finding.description,
                    'severity': finding.severity.value,
                    'category': finding.category,
                    'file_path': finding.file_path,
                    'line_number': finding.line_number,
                    'code_snippet': finding.code_snippet,
                    'cwe_id': finding.cwe_id,
                    'recommendation': finding.recommendation
                })
            
            with open(output_path, 'w') as f:
                json.dump(findings_data, f, indent=2)
        
        logging.info(f"Exported {len(self.findings)} findings to {output_path}")


# Integration function for existing codebase
def scan_repository_vulnerabilities(repo_path: str, 
                                  threshold: str = 'medium') -> Dict[str, Any]:
    """
    Convenience function to scan repository for vulnerabilities.
    
    Args:
        repo_path: Path to repository to scan
        threshold: Minimum severity threshold ('critical', 'high', 'medium', 'low', 'info')
        
    Returns:
        Dictionary containing vulnerability scan results
    """
    severity_map = {
        'critical': VulnerabilitySeverity.CRITICAL,
        'high': VulnerabilitySeverity.HIGH,
        'medium': VulnerabilitySeverity.MEDIUM,
        'low': VulnerabilitySeverity.LOW,
        'info': VulnerabilitySeverity.INFO
    }
    
    threshold_enum = severity_map.get(threshold.lower(), VulnerabilitySeverity.MEDIUM)
    scanner = VulnerabilityScanner(threshold_enum)
    return scanner.scan_repository(repo_path)